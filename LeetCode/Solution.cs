using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Globalization;
using System.Linq;
using System.Net.WebSockets;
using System.Numerics;
using System.Runtime.Intrinsics.Arm;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Serialization;
using static LeetCode.TreesMaster;
using static System.Net.Mime.MediaTypeNames;

namespace LeetCode
{
    public class Solution
    {
        #region Methods
        private void P(double s) => Console.WriteLine(s);
        private void P(string s) => Console.WriteLine(s);
        private void P(int s) => Console.WriteLine(s);
        private void P(bool s) => Console.WriteLine(s);
        private void P(decimal s) => Console.WriteLine(s);
        #endregion
        #region Task 1

        public int[] TwoSum_1(int[] nums, int target)
        {
            for (int i = 0; i < nums.Length; i++)
            {
                int remainder = target - nums[i];
                for (int j = i + 1; j < nums.Length; j++)
                {
                    if (nums[j] == remainder)
                    {
                        return new int[] { i, j };
                    }
                }
            }
            return new int[] { -1, -1 };
        }

        #endregion
        #region Task 5

        #region Solution
        public string LongestPalindrome(string s)
        {
            static bool IsPalindrome(string sub)
            {
                bool res = true;
                int len = sub.Length;
                for (int i = 0; i < len / 2; i++)
                {
                    res &= sub[i] == sub[len - 1 - i];
                }
                return res;
            }
            static string GetExtendedPalindrome(string s, int start, int finish)
            {
                if (IsExtendedPalindrome(s, start, finish))
                {
                    return GetExtendedPalindrome(s, start - 1, finish + 1);
                }
                else
                {
                    return s.Substring(start, finish - start + 1);
                }
            }
            static bool IsExtendedPalindrome(string s, int start, int finish)
            {
                try
                {
                    return s[start - 1] == s[finish + 1];
                }
                catch
                {

                }
                return false;
            }

            int len = s.Length;
            if (len == 0) return "";

            int currSubLen = 2;
            string currSub = "";
            string res = s.Substring(0, 1);

            // for even
            // for odd

            while (currSubLen <= 3)
            {
                for (int i = 0; i <= len - currSubLen; i++)
                {
                    currSub = s.Substring(i, currSubLen);
                    if (IsPalindrome(currSub))
                    {
                        currSub = GetExtendedPalindrome(s, i, i + currSubLen - 1);
                        if (currSub.Length > res.Length)
                        {
                            res = currSub;
                        }
                    }
                }
                currSubLen++;
            }

            return res;
        }
        #endregion
        #region Test
        public void Test5()
        {
            Dictionary<string, string> TestCases = new Dictionary<string, string>()
            {
                { "babad", "bab" },
                { "cbbd", "bb" },
                { "bb", "bb" },
                { "a", "a" }
            };

            foreach (var tc in TestCases)
            {
                Console.ForegroundColor = LongestPalindrome(tc.Key) == tc.Value ? ConsoleColor.Green : ConsoleColor.Red;
                Console.WriteLine($"Input: {tc.Key}");
                Console.WriteLine($"Output: {tc.Value}");
                Console.WriteLine($"MyAnswer: {LongestPalindrome(tc.Key)}\n\n");
            }
            Console.ForegroundColor = ConsoleColor.White;
        }
        #endregion

        #endregion
        #region Task 9

        #region Solution
        public class Solution9
        {
            public bool IsPalindrome(int x)
            {
                if (x < 0) return false;
                char[] xView = Convert.ToString(x).ToCharArray();
                int len = xView.Length;
                char[] revXView = new char[len];
                Array.Copy(xView, revXView, len);
                Array.Reverse(revXView);
                for (int i = 0; i < len; i++)
                    if (xView[i] != revXView[i])
                        return false;
                return true;
            }
        }
        #endregion        
        #region Test
        public void Test_9()
        {
            Solution9 s = new Solution9();
            Console.WriteLine(s.IsPalindrome(10));
        }
        #endregion

        #endregion
        #region Task 11

        #region Solution
        public int MaxArea(int[] height)
        {
            static void SetMaxSquare(ref int max, int i, int j, int[] height)
            {
                int s = Math.Abs(i - j) * Math.Min(height[i], height[j]);
                max = max > s ? max : s;
            }

            int len = height.Length;
            bool[] isVallidLeft = new bool[len];
            bool[] isVallidRight = new bool[len];
            int counterLeft = 0;
            int counterRight = 0;
            int res = 0;

            /*
            if (len == 2)
            {
                SetMaxSquare(ref res, 0, 1, height);
                return res;
            }
            */

            int max = 0;
            for (int i = 0; i < len; i++)
            {
                if (max <= height[i])
                {
                    max = height[i];
                    isVallidLeft[i] = true;
                    counterLeft++;
                }
            }
            max = 0;
            for (int i = len - 1; i >= 0; i--)
            {
                if (max <= height[i])
                {
                    max = height[i];
                    isVallidRight[i] = true;
                    counterRight++;
                }
            }

            if (counterLeft < counterRight)
            {
                for (int i = 0; i < len; i++)
                {
                    if (!isVallidLeft[i])
                        continue;
                    for (int j = i; j < len; j++)
                    {
                        SetMaxSquare(ref res, i, j, height);
                    }
                }
            }
            else
            {
                for (int i = len - 1; i >= 0; i--)
                {
                    if (!isVallidRight[i])
                        continue;
                    for (int j = 0; j < i; j++)
                    {
                        SetMaxSquare(ref res, i, j, height);
                    }
                }
            }

            return res;
        }
        #endregion
        #region Test
        public void Test_11()
        {
            Dictionary<int[], int> TestCases = new Dictionary<int[], int>()
            {
                { new int[] {1,8,6,2,5,4,8,3,7}, 49 },
                { new int[] {1,1}, 1 },
                { new int[] {2,1}, 1 },
                { new int[] {9,6,14,11,2,2,4,9,3,8}, 72 }
            };

            foreach (var tc in TestCases)
            {
                int[] input = tc.Key;
                int output = tc.Value;
                int answer = MaxArea(input);
                Console.ForegroundColor = answer == output ? ConsoleColor.Green : ConsoleColor.Red;
                Console.WriteLine($"Input: {input}");
                Console.WriteLine($"Output: {output}");
                Console.WriteLine($"MyAnswer: {answer}\n\n");
            }
        }
        #endregion

        #endregion
        #region Task 12

        #region Solution
        public string IntToRoman(int num)
        {
            static string GetStrByDigit(char d, char low, char mid, char hight)
            {
                switch (d)
                {
                    case '0':
                        return "";
                    case '1':
                        return "" + low;
                    case '2':
                        return "" + low + low;
                    case '3':
                        return "" + low + low + low;
                    case '4':
                        return "" + low + mid;
                    case '5':
                        return "" + mid;
                    case '6':
                        return "" + mid + low;
                    case '7':
                        return "" + mid + low + low;
                    case '8':
                        return "" + mid + low + low + low;
                    case '9':
                        return "" + low + hight;
                    default:
                        return "";
                }
            }

            string numStr = Convert.ToString(num);
            string res = "";
            if (numStr.Length == 4)
            {
                for (int i = 0; i < num / 1000; i++)
                {
                    res += 'M';
                }
                numStr = numStr.Substring(1);
            }
            if (numStr.Length == 3)
            {
                res += GetStrByDigit(numStr[0], 'C', 'D', 'M');
                numStr = numStr.Substring(1);
            }
            if (numStr.Length == 2)
            {
                res += GetStrByDigit(numStr[0], 'X', 'L', 'C');
                numStr = numStr.Substring(1);
            }
            if (numStr.Length == 1)
            {
                res += GetStrByDigit(numStr[0], 'I', 'V', 'X');
            }
            return res;
        }
        #endregion
        #region Test
        public void Test_12()
        {
            Dictionary<int, string> TestCases = new Dictionary<int, string>()
            {
                { 3, "III" },
                { 58, "LVIII" },
                { 1994, "MCMXCIV" }
            };

            foreach (var tc in TestCases)
            {
                int input = tc.Key;
                string output = tc.Value;
                string answer = IntToRoman(input);
                Console.ForegroundColor = answer == output ? ConsoleColor.Green : ConsoleColor.Red;
                Console.WriteLine($"Input: {input}");
                Console.WriteLine($"Output: {output}");
                Console.WriteLine($"MyAnswer: {answer}\n\n");
            }
        }
        #endregion

        #endregion
        #region Task 13

        public int RomanToInt_13(string s)
        {
            Dictionary<char, int> d = new Dictionary<char, int>();
            d.Add('I', 1);
            d.Add('V', 5);
            d.Add('X', 10);
            d.Add('L', 50);
            d.Add('C', 100);
            d.Add('D', 500);
            d.Add('M', 1000);

            int firstValue = d.GetValueOrDefault(s[0], 0);
            int prevNum = firstValue;
            int currNum = firstValue;
            int res = 0;

            foreach (var c in s)
            {
                currNum = d.GetValueOrDefault(c, 0);
                Console.WriteLine(c + " " + currNum);

                res += currNum;
                Console.WriteLine("res1 " + res);
                if (currNum > prevNum)
                {
                    res -= 2 * prevNum;
                }
                Console.WriteLine("res2 " + res);
                prevNum = currNum;
            }
            return res;
        }

        #endregion
        #region Task 15

        #region Solution
        public IList<IList<int>> ThreeSum(int[] nums)
        {
            static int GetThirdNumInd(int[] nums, int i, int j)
            {
                int c = 0 - nums[i] - nums[j];
                return Array.BinarySearch(nums, c);
            }


            Array.Sort(nums);
            int len = nums.Length;

            IList<IList<int>> res = new List<IList<int>>();
            int thirdInd = 0;
            List<int> currSet = new List<int>();
            for (int i = 0; i < len - 1; i++)
            {
                for (int j = i + 1; j < len; j++)
                {
                    thirdInd = GetThirdNumInd(nums, i, j);
                    if (thirdInd < 0 || thirdInd == i || thirdInd == j)
                        continue;

                    currSet = new List<int>() { nums[i], nums[j], nums[thirdInd] };
                    currSet.Sort();

                    AlgorithmMaster.AddToSortedList(res, currSet);
                }
            }

            return res;
        }
        #endregion
        #region Test
        public void Test_15()
        {
            Dictionary<int[], IList<IList<int>>> TestCases = new Dictionary<int[], IList<IList<int>>>()
            {
                { new int[] {-1,0,1,2,-1,-4}, new List<IList<int>>() { new List<int>(){ -1, -1, 2 }, new List<int>(){ -1, 0, 1 } } },
                { new int[] {0,1,1}, new List<IList<int>>() },
                { new int[] {0,0,0}, new List<IList<int>>() { new List<int>(){ 0, 0, 0 } } },
                {
                    new int[]
                    {
                        82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916
                    },
                    new List<IList<int>>()
                    {
                        new List<int>()
                        {
                            0, 0, 0
                        }
                    }
                }
            };

            foreach (var tc in TestCases)
            {
                int[] input = tc.Key;
                IList<IList<int>> output = tc.Value;
                IList<IList<int>> answer = ThreeSum(input);
                Console.ForegroundColor = OutputMaster.CompareListsOfList(answer, output) ? ConsoleColor.Green : ConsoleColor.Red;
                Console.WriteLine($"Input: {input}");

                Console.WriteLine("Output: ");
                OutputMaster.PrintListOfList(output);
                Console.WriteLine($"MyAnswer: ");
                OutputMaster.PrintListOfList(answer);
                Console.Write("\n\n");
            }
        }
        #endregion

        #endregion
        #region Task 16

        #region Solution
        public int ThreeSumClosest(int[] nums, int target)
        {
            static int GetClosestSum(int[] nums, int target, int i, int j)
            {
                int len = nums.Length;
                int l = 0;
                int r = len - 1;
                int m = 0;

                int third_target = target - nums[i] - nums[j];
                while (l <= r)
                {
                    m = l + (r - l) / 2;

                    if (nums[m] == third_target)
                    {
                        break; // Found the target
                    }
                    else if (nums[m] < third_target)
                    {
                        l = m + 1; // Search the right half
                    }
                    else
                    {
                        r = m - 1; // Search the left half
                    }
                }

                int res = nums[i] + nums[j];
                int third = int.MaxValue / 2;
                if (m != i && m != j && m < len && m >= 0)
                {
                    third = nums[m];
                }
                if (m + 1 != i && m + 1 != j && m + 1 < len && m + 1 >= 0)
                {
                    if (Math.Abs(third_target - nums[m + 1]) < Math.Abs(third_target - third))
                    {
                        third = nums[m + 1];
                    }
                }
                if (m + 2 != i && m + 2 != j && m + 2 < len && m + 2 >= 0)
                {
                    if (Math.Abs(third_target - nums[m + 2]) < Math.Abs(third_target - third))
                    {
                        third = nums[m + 2];
                    }
                }
                if (m - 1 != i && m - 1 != j && m - 1 < len && m - 1 >= 0)
                {
                    if (Math.Abs(third_target - nums[m - 1]) < Math.Abs(third_target - third))
                    {
                        third = nums[m - 1];
                    }
                }
                if (m - 2 != i && m - 2 != j && m - 2 < len && m - 2 >= 0)
                {
                    if (Math.Abs(third_target - nums[m + -2]) < Math.Abs(third_target - third))
                    {
                        third = nums[m - 2];
                    }
                }


                return third + nums[i] + nums[j]; // Target not found
            }
            Array.Sort(nums);
            int len = nums.Length;
            int res = nums[0] + nums[1] + nums[2];
            int currSum = res;
            for (int i = 0; i < len - 1; i++)
            {
                for (int j = i + 1; j < len; j++)
                {
                    currSum = GetClosestSum(nums, target, i, j);
                    res = Math.Abs(target - currSum) < Math.Abs(target - res) ? currSum : res;
                }
            }

            return res;
        }
        #endregion
        #region Test
        public void Test_16()
        {
            Dictionary<KeyValuePair<int[], int>, int> TestCases = new Dictionary<KeyValuePair<int[], int>, int>()
            {
                { new KeyValuePair<int[], int>(new int[] {-1,2,1,-4}, 1), 2},
                { new KeyValuePair<int[], int>(new int[] {0,0,0}, 1), 0},
                { new KeyValuePair<int[], int>(new int[] {0,1,2}, 0), 3}
            };

            foreach (var tc in TestCases)
            {
                KeyValuePair<int[], int> input = tc.Key;
                int output = tc.Value;
                int answer = ThreeSumClosest(input.Key, input.Value);
                string inputStr = string.Join(" ", input.Key);
                inputStr += $"\n{input.Value}";

                Console.ForegroundColor = answer == output ? ConsoleColor.Green : ConsoleColor.Red;
                Console.WriteLine($"Input: {inputStr}");

                Console.WriteLine($"Output: {output}");
                Console.WriteLine($"MyAnswer: {answer}");
                Console.Write("\n\n");
            }
        }
        #endregion

        #endregion
        #region Task 17

        #region Solution
        public IList<string> LetterCombinations(string digits)
        {
            IList<string> res = new List<string>();
            // 0 - 9   a-z
            // 48 - 57 97-122
            Dictionary<char, List<string>> d = new Dictionary<char, List<string>>()
            {
                {'2', new List<string>() {"a", "b", "c"} },
                {'3', new List<string>() {"d", "e", "f"} },

                {'4', new List<string>() {"g", "h", "i"} },
                {'5', new List<string>() {"j", "k", "l"} },
                {'6', new List<string>() {"m", "n", "o"} },

                {'7', new List<string>() {"p", "q", "r", "s"} },
                {'8', new List<string>() {"t", "u", "v"} },
                {'9', new List<string>() {"w", "x", "y", "z"} }
            };
            List<List<string>> comp = new List<List<string>>();
            foreach (char c in digits)
            {
                comp.Add(d[c]);
            }

            if (comp.Count > 0)
                foreach (string s1 in comp[0])
                {
                    if (comp.Count > 1)
                        foreach (string s2 in comp[1])
                        {
                            if (comp.Count > 2)
                                foreach (string s3 in comp[2])
                                {
                                    if (comp.Count > 3)
                                        foreach (string s4 in comp[3])
                                        {
                                            res.Add(s1 + s2 + s3 + s4);
                                        }
                                    else
                                        res.Add(s1 + s2 + s3);
                                }
                            else
                                res.Add(s1 + s2);
                        }
                    else
                        res.Add(s1);
                }

            return res;
        }
        #endregion
        #region Test
        public void Test_17()
        {
            Dictionary<string, IList<string>> TestCases = new Dictionary<string, IList<string>>()
            {
                { "23", new List<string>() { "ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf" } },
                { "", new List<string>() { } },
                { "2", new List<string>(){ "a", "b", "c" } }
            };

            foreach (var tc in TestCases)
            {
                string input = tc.Key;
                IList<string> output = tc.Value;
                IList<string> answer = LetterCombinations(input);

                Console.ForegroundColor = OutputMaster.CompareLists(answer, output) ? ConsoleColor.Green : ConsoleColor.Red;
                Console.WriteLine($"Input: {input}");
                Console.WriteLine($"Output: ");
                OutputMaster.PrintListOfList(output);
                Console.WriteLine($"MyAnswer: ");
                OutputMaster.PrintListOfList(answer);
                Console.WriteLine("\n\n");
            }
            //Console.WriteLine("a " + Convert.ToByte('a'));
            //Console.WriteLine("z " + Convert.ToByte('z'));
            //Console.WriteLine("0 " + Convert.ToByte('0'));
            //Console.WriteLine("9 " + Convert.ToByte('9'));
        }
        #endregion

        #endregion
        #region Task 18

        #region Solution
        public IList<IList<int>> FourSum(int[] nums, int target)
        {
            static bool IsNoRepeats(int a, int b, int c, int d)
            {
                if (a == b || a == c || a == d)
                    return false;

                if (b == c || b == d)
                    return false;

                if (c == d)
                    return false;

                return true;
            }

            IList<IList<int>> res = new List<IList<int>>();
            int len = nums.Length;


            // removing reapets (more 4)
            Dictionary<int, int> repeats = new Dictionary<int, int>();
            int[] mask = new int[len];
            int remLen = 0;
            for (int i = 0; i < len; i++)
            {
                if (!repeats.ContainsKey(nums[i]))
                {
                    repeats.Add(nums[i], 1);
                    continue;
                }

                if (repeats[nums[i]] > 4)
                {
                    mask[i] = 1;
                    remLen += 1;
                }
                else
                {
                    repeats[nums[i]] += 1;
                }
            }

            int[] clearNums = new int[len - remLen];
            for (int i = 0, j = 0; i < len; i++)
            {
                if (mask[i] == 0)
                {
                    clearNums[j] = nums[i];
                    j++;
                }
            }

            len -= remLen;
            nums = clearNums;


            int[,] pairNums = new int[3, len * (len - 1) / 2];
            // Form pairNums with all posible pairs from nums, and pairNumsInd with it`s indexes
            int counter = 0;
            for (int i = 0; i < len - 1; i++)
            {
                for (int j = i + 1; j < len; j++)
                {
                    pairNums[0, counter] = nums[i] + nums[j];
                    pairNums[1, counter] = i;
                    pairNums[2, counter] = j;
                    counter++;
                }
            }

            // Sort pairNums array with CombSort by first array (with sums of two numbers)

            //Console.WriteLine("Before ");
            //OutputMaster.PrintArray(pairNums);
            AlgorithmMaster.CombSort(ref pairNums);
            //Console.WriteLine("After ");
            //OutputMaster.PrintArray(pairNums);

            // Copy first array (with sums of two numbers)
            int[] mainPairArr = new int[counter];
            for (int i = 0; i < counter; i++)
            {
                mainPairArr[i] = pairNums[0, i];
            }

            // Binary searching for pair to pair, and checking indexes
            // TODO Binary search get only one ind, but we need all appropriate
            for (int i = 0; i < counter; i++)
            {
                long delta = (long)target - pairNums[0, i];
                if (delta > int.MaxValue || delta < int.MinValue)
                    continue;

                List<int> inds = AlgorithmMaster.BinarySearchAllIndexes(mainPairArr, (int)delta);
                foreach (int ind in inds)
                {
                    if (ind > -1)
                    {
                        if (IsNoRepeats(pairNums[1, i], pairNums[2, i], pairNums[1, ind], pairNums[2, ind]))
                        {
                            List<int> newSet = new List<int>()
                            {
                                nums[pairNums[1, i]],
                                nums[pairNums[2, i]],
                                nums[pairNums[1, ind]],
                                nums[pairNums[2, ind]]
                            };
                            newSet.Sort();

                            AlgorithmMaster.AddToSortedList(res, newSet);
                        }
                    }
                }
            }

            return res;
        }
        #endregion
        #region Test
        public void Test_18()
        {
            Dictionary<KeyValuePair<int[], int>, IList<IList<int>>> TestCases = new Dictionary<KeyValuePair<int[], int>, IList<IList<int>>>()
            {

                //{ new KeyValuePair<int[], int> (new int[] { 1, 0, -1, 0, -2, 2 }, 0), new List<IList<int>>() { new List<int>(){ -2, -1, 1, 2 }, new List<int>(){ -2, 0, 0, 2 }, new List<int>(){ -1, 0, 0, 1 } } },
                //{ new KeyValuePair<int[], int> (new int[] { 2, 2, 2, 2, 2 }, 8), new List<IList<int>>() { new List<int>(){ 2, 2, 2, 2 } } },
                //{ new KeyValuePair<int[], int> (new int[] { 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2 }, 8), new List<IList<int>>() { new List<int>(){ 2, 2, 2, 2 } } },
                
                { new KeyValuePair<int[], int> (new int[] { 1000000000,1000000000,1000000000,1000000000 }, -294967296), new List<IList<int>>() },

            };

            foreach (var tc in TestCases)
            {
                KeyValuePair<int[], int> input = tc.Key;
                IList<IList<int>> output = tc.Value;
                IList<IList<int>> answer = FourSum(input.Key, input.Value);
                Console.ForegroundColor = OutputMaster.CompareListsOfList(answer, output) ? ConsoleColor.Green : ConsoleColor.Red;
                Console.Write("Input: ");
                OutputMaster.PrintKeyValuePair(input);
                Console.WriteLine("Output: ");
                OutputMaster.PrintListOfList(output);
                Console.WriteLine("MyAnswer: ");
                OutputMaster.PrintListOfList(answer);
                Console.Write("\n\n");
            }
        }
        #endregion

        #endregion
        #region Task 19

        #region Solution
        public class ListNode
        {
            public int val;
            public ListNode next;
            public ListNode(int val = 0, ListNode next = null)
            {
                this.val = val;
                this.next = next;
            }
        }
        public ListNode? RemoveNthFromEnd(ListNode head, int n)
        {
            static int GetLength(ListNode head)
            {
                int res = 1;
                while (head.next is not null)
                {
                    res++;
                    head = head.next;
                }
                return res;
            }
            int len = GetLength(head);
            if (len == 1 && n == 1)
            {
                return null;
            }

            ListNode first = head;

            for (int i = 0; i < len - n - 1; i++)
            {
                head = head.next;
            }

            if (head.next is not null)
                if (len == n)
                    return head.next;
                else if (head.next.next is not null)
                    head.next = head.next.next;
                else
                    head.next = null;


            return first;
        }

        #endregion
        #region Test
        public void Test_19()
        {
            Console.WriteLine(RemoveNthFromEnd(new ListNode(1, new ListNode(2)), 2).next);
        }
        #endregion

        #endregion
        #region Task 20

        #region Solution

        public bool IsValid(string s)
        {
            static void AccountNewScope(int[] a)
            {
                for (int i = 0; i < a.Length; i++)
                {
                    if (a[i] > -1)
                    {
                        a[i] += 1;
                    }
                }
            }

            int len = s.Length;
            int openScopesCounter = 0;
            int closeScopesCounter = 0;
            List<char> openScopes = new List<char> { '(', '{', '[' };
            List<char> closeScopes = new List<char> { ')', '}', ']' };
            Dictionary<char, char> scopePairs = new Dictionary<char, char>
            {
                { ')','(' },
                { '}','{' },
                { ']','[' }
            };
            int[] content = Enumerable.Repeat(-1, len).ToArray();


            for (int i = 0; i < len; i++)
            {
                char currChar = s[i];
                bool isOpenScope = openScopes.Contains(currChar);
                AccountNewScope(content);

                if (isOpenScope)
                {
                    openScopesCounter++;
                    content[i] = 0;
                }
                else
                {
                    closeScopesCounter++;
                    int currContent = 0;
                    char pairScope = scopePairs[currChar];
                    if (i == 0)
                    {
                        return false; // first scope is close scope
                    }
                    for (int j = i - 1; j >= 0; j--)
                    {
                        char checkedChar = s[j];
                        if (content[j] != -1)
                        {
                            if (checkedChar == pairScope)
                            {
                                content[j] = -1;
                                if (currContent % 2 == 1)
                                {
                                    return false; // odd number of scopes in closed space (between current pair)
                                }
                                break;
                            }
                            else
                            {
                                return false; // unclosed scope in closed space (between current pair)
                            }
                        }
                        currContent += 1;

                        if (j == 0)
                        {
                            return false; // there is no open scope
                        }
                    }
                }
            }
            if (openScopesCounter != closeScopesCounter)
                return false;
            return true;
        }

        #endregion
        #region Test

        public void Test20()
        {
            Dictionary<string, bool> TestCases = new Dictionary<string, bool>()
            {
                { "()", true },
                { "()[]{}", true },
                { "(]", false },
                { "[", false },
                { "){", false }
            };

            foreach (var tc in TestCases)
            {
                Console.ForegroundColor = IsValid(tc.Key) == tc.Value ? ConsoleColor.Green : ConsoleColor.Red;
                Console.WriteLine($"Input: {tc.Key}");
                Console.WriteLine($"Output: {tc.Value}");
                Console.WriteLine($"MyAnswer: {IsValid(tc.Key)}\n\n");
            }
        }

        #endregion

        #endregion
        #region Task 67

        #region Solution
        public string AddBinary(string a, string b)
        {
            while (a.Length > b.Length)
                b = "0" + b;
            while (b.Length > a.Length)
                a = "0" + a;
            int len = a.Length;

            string res = "";
            bool shift = false;
            for (int i = len - 1; i >= 0; i--)
            {
                int currVal = ((int)a[i] - 48) + ((int)b[i] - 48);
                if (shift)
                {
                    currVal += 1;
                    shift = false;
                }
                if (currVal == 0) { res = "0" + res; }
                if (currVal == 1) { res = "1" + res; }
                if (currVal == 2) { res = "0" + res; shift = true; }
                if (currVal == 3) { res = "1" + res; shift = true; }
            }
            if (shift)
                res = "1" + res;
            //while(res.Length > 1 && res[0] == '0')
            //res = res.Substring(1);
            return res;
        }
        #endregion        
        #region Test
        public void Test_67()
        {
            Console.WriteLine(AddBinary("11", "1"));
        }
        #endregion

        #endregion
        #region Task 77

        #region Solution
        public class Solution77
        {
            private bool[] positions;
            private IList<IList<int>> combines = new List<IList<int>>();


            private void AddCurrent()
            {
                IList<int> current = new List<int>();
                for (int i = 1; i < positions.Length; i++)
                    if (positions[i])
                        current.Add(i);
                combines.Add(current);
            }


            private bool DoStep()
            {
                bool emptySpace = false;
                for (int i = positions.Length - 1; i >= 0; i--)
                {
                    if (positions[i])
                    {
                        if (emptySpace)
                        {
                            // do step
                            positions[i] = false;
                            positions[i + 1] = true;

                            // left shift
                            int countPointer = 0;
                            for (int j = i + 2; j < positions.Length; j++)
                                if (positions[j])
                                    countPointer++;
                            for (int j = i + 2; j < positions.Length; j++)
                            {
                                if (countPointer > 0)
                                {
                                    positions[j] = true;
                                    countPointer--;
                                }
                                else
                                {
                                    positions[j] = false;
                                }
                            }

                            return true;
                        }
                    }
                    else
                    {
                        emptySpace = true;
                    }
                }
                return false;
            }


            public IList<IList<int>> Combine(int n, int k)
            {
                positions = new bool[n + 1];
                combines = new List<IList<int>>();

                for (int i = 1; i <= k; i++)
                    positions[i] = true;

                bool able = true;
                while (able)
                {
                    AddCurrent();
                    able = DoStep();
                }
                return combines;
            }
        }
        #endregion        
        #region Test
        public void Test_77()
        {
            Solution77 s = new Solution77();
            //OutputMaster.PrintListOfList(s.Combine(4, 2));
            //OutputMaster.PrintListOfList(s.Combine(1, 1));
            //OutputMaster.PrintListOfList(s.Combine(2, 1));
            //OutputMaster.PrintListOfList(s.Combine(3, 2));
            //OutputMaster.PrintListOfList(s.Combine(3, 3));
            OutputMaster.PrintListOfList(s.Combine(10, 9));
        }
        #endregion

        #endregion
        #region Task 190

        #region Solution
        public class Solution190
        {
            public uint reverseBits(uint n)
            {
                uint maxBit = (uint)Math.Pow(2, 31);
                uint nBase = maxBit;
                uint resBase = 1;
                uint res = 0;
                while (nBase >= 1 && resBase <= maxBit)
                {
                    if ((long)n - (long)nBase >= 0)
                    {
                        n -= nBase;
                        res += resBase;
                    }
                    nBase /= 2;
                    resBase *= 2;
                }
                return res;
            }
        }
        #endregion        
        #region Test
        public void Test_190()
        {
            Solution190 s = new Solution190();
            Console.WriteLine(s.reverseBits(1536));
            Console.WriteLine(s.reverseBits(43261596));
            //43261596
            Console.WriteLine("00000010100101000001111010011100".Length);
        }
        #endregion

        #endregion
        #region Task 205

        #region Solution
        public bool IsIsomorphic(string s, string t)
        {
            if (s.Length != t.Length)
                return false;

            Dictionary<char, char> sToT = new Dictionary<char, char>();
            Dictionary<char, char> tToS = new Dictionary<char, char>();

            for (int i = 0; i < s.Length; i++)
            {
                char sChar = s[i];
                char tChar = t[i];

                if (sToT.ContainsKey(sChar))
                {
                    if (sToT[sChar] != tChar)
                        return false;
                }
                else if (tToS.ContainsKey(tChar))
                {
                    if (tToS[tChar] != sChar)
                        return false;
                }
                else
                {
                    sToT[sChar] = tChar;
                    tToS[tChar] = sChar;
                }
            }
            return true;
        }
        #endregion        
        #region Test
        public void Test_205()
        {
            Console.WriteLine(IsIsomorphic("egg", "add"));
        }
        #endregion

        #endregion
        #region Task 211

        #region Solution
        public class WordDictionary211
        {
            private Dictionary<string, bool> words;
            public WordDictionary211() => words = new Dictionary<string, bool>();

            private bool Equals(string w1, string w2)
            {
                int len = w1.Length;
                if (len != w2.Length) return false;
                for (int i = 0; i < len; i++)
                {
                    if (w1[i] == '.' || w2[i] == '.') continue;
                    if (w1[i] != w2[i])
                        return false;
                }
                return true;
            }

            public void AddWord(string word)
            {
                if (!words.ContainsKey(word))
                    words.Add(word, true);
            }

            public bool Search(string word)
            {
                foreach (var w in words)
                    if (Equals(w.Key, word))
                        return true;
                return false;
            }
        }
        #endregion
        #region Test
        public void Test_211()
        {
            WordDictionary211 wordDictionary1 = new WordDictionary211();
            wordDictionary1.AddWord("bad");
            wordDictionary1.AddWord("dad");
            wordDictionary1.AddWord("mad");
            P(wordDictionary1.Search("pad"));
            P(wordDictionary1.Search("bad"));
            P(wordDictionary1.Search(".ad"));
            P(wordDictionary1.Search("b.."));

            //WordDictionary211 wordDictionary2 = new WordDictionary211();
            //wordDictionary2.AddWord("a");
            //wordDictionary2.AddWord("a");
            //P(wordDictionary2.Search("."));
            //P(wordDictionary2.Search("a"));
            //P(wordDictionary2.Search("aa"));
            //P(wordDictionary2.Search("a"));
            //P(wordDictionary2.Search(".a"));
            //P(wordDictionary2.Search("a."));
        }
        #endregion

        #endregion
        #region Task 264

        #region Solution
        public class Solution264
        {
            public static void MultiDevition(ref int num, int dev)
            {
                while (num % dev == 0) num = num / dev;
            }
            public string Generator(int count)
            {
                StringBuilder res = new StringBuilder();
                int currCount = 0;
                int num = 1;
                int n = 0;
                res.Append("int[] nums = {");
                while (currCount <= count)
                {
                    n = num;
                    MultiDevition(ref n, 2);
                    MultiDevition(ref n, 3);
                    MultiDevition(ref n, 5);
                    if (n == 1)
                    {
                        res.Append($",{num}");
                        currCount++;
                    }
                    num++;
                }
                res.Append("}");
                return res.ToString();
            }

            public int NthUglyNumber(int n)
            {
                int[] nums = { 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162, 180, 192, 200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320, 324, 360, 375, 384, 400, 405, 432, 450, 480, 486, 500, 512, 540, 576, 600, 625, 640, 648, 675, 720, 729, 750, 768, 800, 810, 864, 900, 960, 972, 1000, 1024, 1080, 1125, 1152, 1200, 1215, 1250, 1280, 1296, 1350, 1440, 1458, 1500, 1536, 1600, 1620, 1728, 1800, 1875, 1920, 1944, 2000, 2025, 2048, 2160, 2187, 2250, 2304, 2400, 2430, 2500, 2560, 2592, 2700, 2880, 2916, 3000, 3072, 3125, 3200, 3240, 3375, 3456, 3600, 3645, 3750, 3840, 3888, 4000, 4050, 4096, 4320, 4374, 4500, 4608, 4800, 4860, 5000, 5120, 5184, 5400, 5625, 5760, 5832, 6000, 6075, 6144, 6250, 6400, 6480, 6561, 6750, 6912, 7200, 7290, 7500, 7680, 7776, 8000, 8100, 8192, 8640, 8748, 9000, 9216, 9375, 9600, 9720, 10000, 10125, 10240, 10368, 10800, 10935, 11250, 11520, 11664, 12000, 12150, 12288, 12500, 12800, 12960, 13122, 13500, 13824, 14400, 14580, 15000, 15360, 15552, 15625, 16000, 16200, 16384, 16875, 17280, 17496, 18000, 18225, 18432, 18750, 19200, 19440, 19683, 20000, 20250, 20480, 20736, 21600, 21870, 22500, 23040, 23328, 24000, 24300, 24576, 25000, 25600, 25920, 26244, 27000, 27648, 28125, 28800, 29160, 30000, 30375, 30720, 31104, 31250, 32000, 32400, 32768, 32805, 33750, 34560, 34992, 36000, 36450, 36864, 37500, 38400, 38880, 39366, 40000, 40500, 40960, 41472, 43200, 43740, 45000, 46080, 46656, 46875, 48000, 48600, 49152, 50000, 50625, 51200, 51840, 52488, 54000, 54675, 55296, 56250, 57600, 58320, 59049, 60000, 60750, 61440, 62208, 62500, 64000, 64800, 65536, 65610, 67500, 69120, 69984, 72000, 72900, 73728, 75000, 76800, 77760, 78125, 78732, 80000, 81000, 81920, 82944, 84375, 86400, 87480, 90000, 91125, 92160, 93312, 93750, 96000, 97200, 98304, 98415, 100000, 101250, 102400, 103680, 104976, 108000, 109350, 110592, 112500, 115200, 116640, 118098, 120000, 121500, 122880, 124416, 125000, 128000, 129600, 131072, 131220, 135000, 138240, 139968, 140625, 144000, 145800, 147456, 150000, 151875, 153600, 155520, 156250, 157464, 160000, 162000, 163840, 164025, 165888, 168750, 172800, 174960, 177147, 180000, 182250, 184320, 186624, 187500, 192000, 194400, 196608, 196830, 200000, 202500, 204800, 207360, 209952, 216000, 218700, 221184, 225000, 230400, 233280, 234375, 236196, 240000, 243000, 245760, 248832, 250000, 253125, 256000, 259200, 262144, 262440, 270000, 273375, 276480, 279936, 281250, 288000, 291600, 294912, 295245, 300000, 303750, 307200, 311040, 312500, 314928, 320000, 324000, 327680, 328050, 331776, 337500, 345600, 349920, 354294, 360000, 364500, 368640, 373248, 375000, 384000, 388800, 390625, 393216, 393660, 400000, 405000, 409600, 414720, 419904, 421875, 432000, 437400, 442368, 450000, 455625, 460800, 466560, 468750, 472392, 480000, 486000, 491520, 492075, 497664, 500000, 506250, 512000, 518400, 524288, 524880, 531441, 540000, 546750, 552960, 559872, 562500, 576000, 583200, 589824, 590490, 600000, 607500, 614400, 622080, 625000, 629856, 640000, 648000, 655360, 656100, 663552, 675000, 691200, 699840, 703125, 708588, 720000, 729000, 737280, 746496, 750000, 759375, 768000, 777600, 781250, 786432, 787320, 800000, 810000, 819200, 820125, 829440, 839808, 843750, 864000, 874800, 884736, 885735, 900000, 911250, 921600, 933120, 937500, 944784, 960000, 972000, 983040, 984150, 995328, 1000000, 1012500, 1024000, 1036800, 1048576, 1049760, 1062882, 1080000, 1093500, 1105920, 1119744, 1125000, 1152000, 1166400, 1171875, 1179648, 1180980, 1200000, 1215000, 1228800, 1244160, 1250000, 1259712, 1265625, 1280000, 1296000, 1310720, 1312200, 1327104, 1350000, 1366875, 1382400, 1399680, 1406250, 1417176, 1440000, 1458000, 1474560, 1476225, 1492992, 1500000, 1518750, 1536000, 1555200, 1562500, 1572864, 1574640, 1594323, 1600000, 1620000, 1638400, 1640250, 1658880, 1679616, 1687500, 1728000, 1749600, 1769472, 1771470, 1800000, 1822500, 1843200, 1866240, 1875000, 1889568, 1920000, 1944000, 1953125, 1966080, 1968300, 1990656, 2000000, 2025000, 2048000, 2073600, 2097152, 2099520, 2109375, 2125764, 2160000, 2187000, 2211840, 2239488, 2250000, 2278125, 2304000, 2332800, 2343750, 2359296, 2361960, 2400000, 2430000, 2457600, 2460375, 2488320, 2500000, 2519424, 2531250, 2560000, 2592000, 2621440, 2624400, 2654208, 2657205, 2700000, 2733750, 2764800, 2799360, 2812500, 2834352, 2880000, 2916000, 2949120, 2952450, 2985984, 3000000, 3037500, 3072000, 3110400, 3125000, 3145728, 3149280, 3188646, 3200000, 3240000, 3276800, 3280500, 3317760, 3359232, 3375000, 3456000, 3499200, 3515625, 3538944, 3542940, 3600000, 3645000, 3686400, 3732480, 3750000, 3779136, 3796875, 3840000, 3888000, 3906250, 3932160, 3936600, 3981312, 4000000, 4050000, 4096000, 4100625, 4147200, 4194304, 4199040, 4218750, 4251528, 4320000, 4374000, 4423680, 4428675, 4478976, 4500000, 4556250, 4608000, 4665600, 4687500, 4718592, 4723920, 4782969, 4800000, 4860000, 4915200, 4920750, 4976640, 5000000, 5038848, 5062500, 5120000, 5184000, 5242880, 5248800, 5308416, 5314410, 5400000, 5467500, 5529600, 5598720, 5625000, 5668704, 5760000, 5832000, 5859375, 5898240, 5904900, 5971968, 6000000, 6075000, 6144000, 6220800, 6250000, 6291456, 6298560, 6328125, 6377292, 6400000, 6480000, 6553600, 6561000, 6635520, 6718464, 6750000, 6834375, 6912000, 6998400, 7031250, 7077888, 7085880, 7200000, 7290000, 7372800, 7381125, 7464960, 7500000, 7558272, 7593750, 7680000, 7776000, 7812500, 7864320, 7873200, 7962624, 7971615, 8000000, 8100000, 8192000, 8201250, 8294400, 8388608, 8398080, 8437500, 8503056, 8640000, 8748000, 8847360, 8857350, 8957952, 9000000, 9112500, 9216000, 9331200, 9375000, 9437184, 9447840, 9565938, 9600000, 9720000, 9765625, 9830400, 9841500, 9953280, 10000000, 10077696, 10125000, 10240000, 10368000, 10485760, 10497600, 10546875, 10616832, 10628820, 10800000, 10935000, 11059200, 11197440, 11250000, 11337408, 11390625, 11520000, 11664000, 11718750, 11796480, 11809800, 11943936, 12000000, 12150000, 12288000, 12301875, 12441600, 12500000, 12582912, 12597120, 12656250, 12754584, 12800000, 12960000, 13107200, 13122000, 13271040, 13286025, 13436928, 13500000, 13668750, 13824000, 13996800, 14062500, 14155776, 14171760, 14348907, 14400000, 14580000, 14745600, 14762250, 14929920, 15000000, 15116544, 15187500, 15360000, 15552000, 15625000, 15728640, 15746400, 15925248, 15943230, 16000000, 16200000, 16384000, 16402500, 16588800, 16777216, 16796160, 16875000, 17006112, 17280000, 17496000, 17578125, 17694720, 17714700, 17915904, 18000000, 18225000, 18432000, 18662400, 18750000, 18874368, 18895680, 18984375, 19131876, 19200000, 19440000, 19531250, 19660800, 19683000, 19906560, 20000000, 20155392, 20250000, 20480000, 20503125, 20736000, 20971520, 20995200, 21093750, 21233664, 21257640, 21600000, 21870000, 22118400, 22143375, 22394880, 22500000, 22674816, 22781250, 23040000, 23328000, 23437500, 23592960, 23619600, 23887872, 23914845, 24000000, 24300000, 24576000, 24603750, 24883200, 25000000, 25165824, 25194240, 25312500, 25509168, 25600000, 25920000, 26214400, 26244000, 26542080, 26572050, 26873856, 27000000, 27337500, 27648000, 27993600, 28125000, 28311552, 28343520, 28697814, 28800000, 29160000, 29296875, 29491200, 29524500, 29859840, 30000000, 30233088, 30375000, 30720000, 31104000, 31250000, 31457280, 31492800, 31640625, 31850496, 31886460, 32000000, 32400000, 32768000, 32805000, 33177600, 33554432, 33592320, 33750000, 34012224, 34171875, 34560000, 34992000, 35156250, 35389440, 35429400, 35831808, 36000000, 36450000, 36864000, 36905625, 37324800, 37500000, 37748736, 37791360, 37968750, 38263752, 38400000, 38880000, 39062500, 39321600, 39366000, 39813120, 39858075, 40000000, 40310784, 40500000, 40960000, 41006250, 41472000, 41943040, 41990400, 42187500, 42467328, 42515280, 43046721, 43200000, 43740000, 44236800, 44286750, 44789760, 45000000, 45349632, 45562500, 46080000, 46656000, 46875000, 47185920, 47239200, 47775744, 47829690, 48000000, 48600000, 48828125, 49152000, 49207500, 49766400, 50000000, 50331648, 50388480, 50625000, 51018336, 51200000, 51840000, 52428800, 52488000, 52734375, 53084160, 53144100, 53747712, 54000000, 54675000, 55296000, 55987200, 56250000, 56623104, 56687040, 56953125, 57395628, 57600000, 58320000, 58593750, 58982400, 59049000, 59719680, 60000000, 60466176, 60750000, 61440000, 61509375, 62208000, 62500000, 62914560, 62985600, 63281250, 63700992, 63772920, 64000000, 64800000, 65536000, 65610000, 66355200, 66430125, 67108864, 67184640, 67500000, 68024448, 68343750, 69120000, 69984000, 70312500, 70778880, 70858800, 71663616, 71744535, 72000000, 72900000, 73728000, 73811250, 74649600, 75000000, 75497472, 75582720, 75937500, 76527504, 76800000, 77760000, 78125000, 78643200, 78732000, 79626240, 79716150, 80000000, 80621568, 81000000, 81920000, 82012500, 82944000, 83886080, 83980800, 84375000, 84934656, 85030560, 86093442, 86400000, 87480000, 87890625, 88473600, 88573500, 89579520, 90000000, 90699264, 91125000, 92160000, 93312000, 93750000, 94371840, 94478400, 94921875, 95551488, 95659380, 96000000, 97200000, 97656250, 98304000, 98415000, 99532800, 100000000, 100663296, 100776960, 101250000, 102036672, 102400000, 102515625, 103680000, 104857600, 104976000, 105468750, 106168320, 106288200, 107495424, 108000000, 109350000, 110592000, 110716875, 111974400, 112500000, 113246208, 113374080, 113906250, 114791256, 115200000, 116640000, 117187500, 117964800, 118098000, 119439360, 119574225, 120000000, 120932352, 121500000, 122880000, 123018750, 124416000, 125000000, 125829120, 125971200, 126562500, 127401984, 127545840, 128000000, 129140163, 129600000, 131072000, 131220000, 132710400, 132860250, 134217728, 134369280, 135000000, 136048896, 136687500, 138240000, 139968000, 140625000, 141557760, 141717600, 143327232, 143489070, 144000000, 145800000, 146484375, 147456000, 147622500, 149299200, 150000000, 150994944, 151165440, 151875000, 153055008, 153600000, 155520000, 156250000, 157286400, 157464000, 158203125, 159252480, 159432300, 160000000, 161243136, 162000000, 163840000, 164025000, 165888000, 167772160, 167961600, 168750000, 169869312, 170061120, 170859375, 172186884, 172800000, 174960000, 175781250, 176947200, 177147000, 179159040, 180000000, 181398528, 182250000, 184320000, 184528125, 186624000, 187500000, 188743680, 188956800, 189843750, 191102976, 191318760, 192000000, 194400000, 195312500, 196608000, 196830000, 199065600, 199290375, 200000000, 201326592, 201553920, 202500000, 204073344, 204800000, 205031250, 207360000, 209715200, 209952000, 210937500, 212336640, 212576400, 214990848, 215233605, 216000000, 218700000, 221184000, 221433750, 223948800, 225000000, 226492416, 226748160, 227812500, 229582512, 230400000, 233280000, 234375000, 235929600, 236196000, 238878720, 239148450, 240000000, 241864704, 243000000, 244140625, 245760000, 246037500, 248832000, 250000000, 251658240, 251942400, 253125000, 254803968, 255091680, 256000000, 258280326, 259200000, 262144000, 262440000, 263671875, 265420800, 265720500, 268435456, 268738560, 270000000, 272097792, 273375000, 276480000, 279936000, 281250000, 283115520, 283435200, 284765625, 286654464, 286978140, 288000000, 291600000, 292968750, 294912000, 295245000, 298598400, 300000000, 301989888, 302330880, 303750000, 306110016, 307200000, 307546875, 311040000, 312500000, 314572800, 314928000, 316406250, 318504960, 318864600, 320000000, 322486272, 324000000, 327680000, 328050000, 331776000, 332150625, 335544320, 335923200, 337500000, 339738624, 340122240, 341718750, 344373768, 345600000, 349920000, 351562500, 353894400, 354294000, 358318080, 358722675, 360000000, 362797056, 364500000, 368640000, 369056250, 373248000, 375000000, 377487360, 377913600, 379687500, 382205952, 382637520, 384000000, 387420489, 388800000, 390625000, 393216000, 393660000, 398131200, 398580750, 400000000, 402653184, 403107840, 405000000, 408146688, 409600000, 410062500, 414720000, 419430400, 419904000, 421875000, 424673280, 425152800, 429981696, 430467210, 432000000, 437400000, 439453125, 442368000, 442867500, 447897600, 450000000, 452984832, 453496320, 455625000, 459165024, 460800000, 466560000, 468750000, 471859200, 472392000, 474609375, 477757440, 478296900, 480000000, 483729408, 486000000, 488281250, 491520000, 492075000, 497664000, 500000000, 503316480, 503884800, 506250000, 509607936, 510183360, 512000000, 512578125, 516560652, 518400000, 524288000, 524880000, 527343750, 530841600, 531441000, 536870912, 537477120, 540000000, 544195584, 546750000, 552960000, 553584375, 559872000, 562500000, 566231040, 566870400, 569531250, 573308928, 573956280, 576000000, 583200000, 585937500, 589824000, 590490000, 597196800, 597871125, 600000000, 603979776, 604661760, 607500000, 612220032, 614400000, 615093750, 622080000, 625000000, 629145600, 629856000, 632812500, 637009920, 637729200, 640000000, 644972544, 645700815, 648000000, 655360000, 656100000, 663552000, 664301250, 671088640, 671846400, 675000000, 679477248, 680244480, 683437500, 688747536, 691200000, 699840000, 703125000, 707788800, 708588000, 716636160, 717445350, 720000000, 725594112, 729000000, 732421875, 737280000, 738112500, 746496000, 750000000, 754974720, 755827200, 759375000, 764411904, 765275040, 768000000, 774840978, 777600000, 781250000, 786432000, 787320000, 791015625, 796262400, 797161500, 800000000, 805306368, 806215680, 810000000, 816293376, 819200000, 820125000, 829440000, 838860800, 839808000, 843750000, 849346560, 850305600, 854296875, 859963392, 860934420, 864000000, 874800000, 878906250, 884736000, 885735000, 895795200, 900000000, 905969664, 906992640, 911250000, 918330048, 921600000, 922640625, 933120000, 937500000, 943718400, 944784000, 949218750, 955514880, 956593800, 960000000, 967458816, 972000000, 976562500, 983040000, 984150000, 995328000, 996451875, 1000000000, 1006632960, 1007769600, 1012500000, 1019215872, 1020366720, 1024000000, 1025156250, 1033121304, 1036800000, 1048576000, 1049760000, 1054687500, 1061683200, 1062882000, 1073741824, 1074954240, 1076168025, 1080000000, 1088391168, 1093500000, 1105920000, 1107168750, 1119744000, 1125000000, 1132462080, 1133740800, 1139062500, 1146617856, 1147912560, 1152000000, 1162261467, 1166400000, 1171875000, 1179648000, 1180980000, 1194393600, 1195742250, 1200000000, 1207959552, 1209323520, 1215000000, 1220703125, 1224440064, 1228800000, 1230187500, 1244160000, 1250000000, 1258291200, 1259712000, 1265625000, 1274019840, 1275458400, 1280000000, 1289945088, 1291401630, 1296000000, 1310720000, 1312200000, 1318359375, 1327104000, 1328602500, 1342177280, 1343692800, 1350000000, 1358954496, 1360488960, 1366875000, 1377495072, 1382400000, 1399680000, 1406250000, 1415577600, 1417176000, 1423828125, 1433272320, 1434890700, 1440000000, 1451188224, 1458000000, 1464843750, 1474560000, 1476225000, 1492992000, 1500000000, 1509949440, 1511654400, 1518750000, 1528823808, 1530550080, 1536000000, 1537734375, 1549681956, 1555200000, 1562500000, 1572864000, 1574640000, 1582031250, 1592524800, 1594323000, 1600000000, 1610612736, 1612431360, 1620000000, 1632586752, 1638400000, 1640250000, 1658880000, 1660753125, 1677721600, 1679616000, 1687500000, 1698693120, 1700611200, 1708593750, 1719926784, 1721868840, 1728000000, 1749600000, 1757812500, 1769472000, 1771470000, 1791590400, 1793613375, 1800000000, 1811939328, 1813985280, 1822500000, 1836660096, 1843200000, 1845281250, 1866240000, 1875000000, 1887436800, 1889568000, 1898437500, 1911029760, 1913187600, 1920000000, 1934917632, 1937102445, 1944000000, 1953125000, 1966080000, 1968300000, 1990656000, 1992903750, 2000000000, 2013265920, 2015539200, 2025000000, 2038431744, 2040733440, 2048000000, 2050312500, 2066242608, 2073600000, 2097152000, 2099520000, 2109375000, 2123366400, 2125764000 };
                return nums[n - 1];
            }
        }
        #endregion        
        #region Test
        public void Test_264()
        {
            Solution264 s = new Solution264();
            //P(s.Generator(1690));
            P(s.NthUglyNumber(1));
            P(s.NthUglyNumber(10));
        }
        #endregion

        #endregion
        #region Task 287

        #region Solution
        public int FindDuplicate(int[] nums)
        {
            int len = nums.Length;
            int[] res = new int[len];
            for (int i = 0; i < len; i++)
                res[nums[i]]++;

            int maxEl = 0;
            int maxInd = 0;
            for (int i = 0; i < len; i++)
            {
                if (res[i] > maxEl)
                {
                    maxEl = res[i];
                    maxInd = i;
                }
            }
            return maxInd;
        }
        #endregion        
        #region Test
        public void Test_287()
        {
            Console.WriteLine(FindDuplicate(new int[] { 3, 1, 3, 4, 2 }));
        }
        #endregion

        #endregion
        #region Task 322

        #region Solution
        public class Solution322
        {
            public int CoinChange(int[] coins, int amount)
            {
                int n = coins.Length;
                int[][] dp = new int[n][];
                for (int i = 0; i < dp.Length; i++)
                {
                    dp[i] = new int[10001];
                    Array.Fill(dp[i], -1);
                }
                int solve(int idx, int remind)
                {
                    if (idx >= n || remind < 0) return Int32.MaxValue - 1;
                    if (dp[idx][remind] != -1) return dp[idx][remind];
                    if (remind == 0) return 0;
                    int op1 = solve(idx + 1, remind);
                    int op2 = solve(idx, remind - coins[idx]) + 1;
                    return dp[idx][remind] = Math.Min(op1, op2);
                }
                int res = solve(0, amount);
                if (res >= Int32.MaxValue - 1) return -1;
                return res;
            }
        }
        #endregion        
        #region Test
        public void Test_322()
        {
            Solution322 s = new Solution322();
            int[] coins = { 186, 419, 83, 408 };
            int amount = 6249;
            P(s.CoinChange(coins, amount));

            int[] coins2 = { 4, 5, 6 };
            int amount2 = 17;
            P(s.CoinChange(coins2, amount2));
        }
        #endregion

        #endregion
        #region Task 345

        #region Solution
        public class Solution345
        {
            public string ReverseVowels(string s)
            {
                string allVowels = "aeiouAEIOU";

                List<char> vowels = new List<char>();
                int len = s.Length;
                for (int i = 0; i < len; i++)
                    if (allVowels.IndexOf(s[i]) != -1)
                        vowels.Add(s[i]);
                vowels.Reverse();

                StringBuilder res = new StringBuilder();
                int listInd = 0;
                for (int i = 0; i < len; i++)
                {
                    if (allVowels.IndexOf(s[i]) != -1)
                    {
                        res.Append(vowels[listInd]);
                        listInd++;
                    }
                    else
                    {
                        res.Append(s[i]);
                    }
                }

                return res.ToString();
            }
        }
        #endregion        
        #region Test
        public void Test_345()
        {
            Solution345 s = new Solution345();
            Console.WriteLine(s.ReverseVowels("hello"));
            Console.WriteLine(s.ReverseVowels("leetcode"));
            Console.WriteLine(s.ReverseVowels("aa"));
            Console.WriteLine(s.ReverseVowels("aA"));
            //aA
        }
        #endregion

        #endregion
        #region Task 350

        #region Solution
        public class Solution350
        {
            private Dictionary<int, int> ToDict(int[] arr)
            {
                Dictionary<int, int> elms = new Dictionary<int, int>();
                for (int i = 0; i < arr.Length; i++)
                {
                    if (!elms.ContainsKey(arr[i]))
                        elms.Add(arr[i], 0);
                    elms[arr[i]]++;
                }
                return elms;
            }
            public int[] Intersect(int[] nums1, int[] nums2)
            {
                Dictionary<int, int> elms1 = ToDict(nums1);
                Dictionary<int, int> elms2 = ToDict(nums2);
                List<int> res = new List<int>();
                foreach (var p in elms1)
                {
                    int num = p.Key;
                    int elCount1 = p.Value;
                    if (!elms2.ContainsKey(num)) continue;
                    int elCount2 = elms2[num];
                    int resCount = elCount1 < elCount2 ? elCount1 : elCount2;
                    for (int j = 0; j < resCount; j++)
                        res.Add(num);
                }
                return res.ToArray();
            }
        }
        #endregion        
        #region Test
        public void Test_350()
        {
            Solution350 s = new Solution350();
            OutputMaster.PrintArray(s.Intersect(new int[] { 1, 2, 2, 1 }, new int[] { 2, 2 }));
        }
        #endregion

        #endregion
        #region Task 495

        #region Solution
        public class Solution495
        {
            public int FindPoisonedDuration(int[] timeSeries, int duration)
            {
                int res = 0;
                int poisonEffect = 0;
                int start = 0;
                int finish = 0;
                int repoisonFinish = 0;
                int durationFinish = 0;

                for (int i = 0; i < timeSeries.Length - 1; i++)
                {
                    start = timeSeries[i];
                    repoisonFinish = timeSeries[i + 1] - 1;
                    durationFinish = timeSeries[i] + duration - 1;

                    if (repoisonFinish < durationFinish)
                    {
                        finish = repoisonFinish;
                    }
                    else
                    {
                        finish = durationFinish;
                    }
                    res += finish - start + 1;
                }
                res += duration;
                return res;
            }
        }
        #endregion        
        #region Test
        public void Test_495()
        {
            Solution495 s = new Solution495();
            P(s.FindPoisonedDuration(new int[] { 1, 4 }, 2));
        }
        #endregion

        #endregion
        #region Task 507

        #region Solution
        public class Solution507
        {
            public bool CheckPerfectNumber(int num)
            {
                List<int> dev = new List<int>();
                int clone = num;
                int res = 0;
                int m = (int)Math.Sqrt((double)num);
                while (m > 0)
                {
                    if (clone % m == 0)
                        dev.Add(m);
                    m--;
                }

                int d2 = 0;
                foreach (var d1 in dev)
                {
                    d2 = num / d1;
                    res += d1;
                    if (d2 != d1) res += d2;
                }
                return res / 2 == num;
            }
        }
        #endregion        
        #region Test
        public void Test_507()
        {
            Solution507 s = new Solution507();
            P(s.CheckPerfectNumber(28));
            P(s.CheckPerfectNumber(7));
        }
        #endregion

        #endregion
        #region Task 526

        #region Solution
        public class Solution526
        {
            private int n;
            private IList<IList<int>> devs = new List<IList<int>>();
            public int Rec(int step, List<int> avbNums)
            {
                if (avbNums.Count == 0) return 1;
                List<int> nextAvbNums;
                int res = 0;
                for (int i = 0; i < avbNums.Count; i++)
                {
                    int currNum = avbNums[i];
                    if (!devs[step].Contains(currNum))
                        continue;
                    nextAvbNums = new List<int>(avbNums);
                    nextAvbNums.Remove(currNum);
                    res += Rec(step + 1, nextAvbNums);
                }
                return res;
            }
            public IList<int> DoubleFactorization(int ind, int n)
            {
                IList<int> res = new List<int>();
                int d = 1;
                while (d <= ind)
                {
                    if (ind % d == 0)
                        res.Add(d);
                    d++;
                }

                for (int i = 1; i <= n; i++)
                    if (i % ind == 0 && !res.Contains(i))
                        res.Add(i);
                return res;
            }
            public int CountArrangement(int n)
            {
                int[] res = new int[] { -1, 1, 2, 3, 8, 10, 36, 41, 132, 250, 700, 750, 4010, 4237, 10680, 24679 };
                this.n = n;
                devs = new List<IList<int>>() { new List<int>() };

                // 1 - n inds
                for (int i = 1; i <= n; i++)
                    devs.Add(DoubleFactorization(i, n));

                List<int> avbNums = new List<int>();
                for (int i = 1; i <= n; i++)
                    avbNums.Add(i);

                // return Rec(1, avbNums);
                return res[n];
            }

            public string ResArrayGenerator(int n)
            {
                string arrStr = "int[] res = new int[] {";
                for (int i = 1; i < n; i++)
                    arrStr += $"{CountArrangement(i)}, ";
                arrStr += CountArrangement(n);
                arrStr += "};";
                return arrStr;
            }
        }
        #endregion
        #region Test
        public void Test_526()
        {
            Solution526 s = new Solution526();

            // P(s.ResArrayGenerator(15));
            P(s.CountArrangement(2));
            P(s.CountArrangement(1));
        }
        #endregion

        #endregion
        #region Task 599

        #region Solution
        public string[] FindRestaurant(string[] list1, string[] list2)
        {
            int minIndSum = (list1.Length - 1) + (list2.Length - 1);
            List<string> resList = new List<string>();
            for (int i = 0; i < list1.Length; i++)
            {
                string currStr = list1[i];
                int pairInd = Array.IndexOf(list2, currStr);
                if (pairInd == -1)
                    continue;
                int currIndSum = i + pairInd;
                if (currIndSum == minIndSum)
                    resList.Add(currStr);
                if (currIndSum < minIndSum)
                {
                    resList = new List<string> { currStr };
                    minIndSum = currIndSum;
                }
            }
            return resList.ToArray();
        }
        #endregion        
        #region Test
        public void Test_599()
        {
            string[] list1 = { "Shogun", "Tapioca Express", "Burger King", "KFC" };
            string[] list2 = { "KFC", "Shogun", "Burger King" };
            OutputMaster.PrintArray(FindRestaurant(list1, list2));
        }
        #endregion

        #endregion
        #region Task 916

        #region Solution
        public bool isSubset(string str, string subStr)
        {
            foreach (var c in subStr)
            {
                int ind = str.IndexOf(c);
                if (ind == -1)
                    return false;
                str = str.Remove(ind, 1);
            }
            return true;
        }
        public IList<string> WordSubsets(string[] words1, string[] words2)
        {
            List<string> res = new List<string>();
            foreach (var w1 in words1)
            {
                bool isSuit = true;
                foreach (var w2 in words2)
                {
                    isSuit &= isSubset(w1, w2);
                }
                if (isSuit)
                    res.Add(w1);
            }
            return res;
        }
        #endregion        
        #region Test
        public void Test_916()
        {
            string[] w1 = { "amazon", "apple", "facebook", "google", "leetcode" };
            string[] w2 = { "e", "oo" };
            OutputMaster.PrintList(WordSubsets(w1, w2));

        }
        #endregion

        #endregion
        #region Task 944

        #region Solution

        public int MinDeletionSize(string[] strs)
        {
            bool[] colomnsDelete = new bool[strs[0].Length];
            
            string prevStr = strs[0];
            int strLen = prevStr.Length;
            int res = 0;
            for (int i = 0; i < strs.Length; i++)
            {
                string currStr = strs[i];
                for (int j = 0; j < strLen; j++)
                {
                    if (colomnsDelete[j])
                        continue;
                    if (prevStr[j] > currStr[j])
                    {
                        colomnsDelete[j] = true;
                        res += 1;
                    }
                        
                }
                prevStr = currStr;
            }
            return res;
        }

        #endregion        
        #region Test
        public void Test_944()
        {
            //string[] input_1 = { "cba", "daf", "ghi" };
            //Console.WriteLine(MinDeletionSize(input_1));

            //string[] input_2 = { "a", "b" };
            //Console.WriteLine(MinDeletionSize(input_2));

            //string[] input_3 = { "zyx", "wvu", "tsr" };
            //Console.WriteLine(MinDeletionSize(input_3));

            string[] input_4 = { "rrjk", "furt", "guzm" };
            Console.WriteLine(MinDeletionSize(input_4));
        }

        #endregion

        #endregion
        #region Task 949

        #region Solution
        public string LargestTimeFromDigits(int[] arr)
        {
            Array.Sort(arr);

            int maxHours = -1;
            int maxMinutes = -1;
            for (int i0 = 0; i0 < 4; i0++)
            {
                for (int i1 = 0; i1 < 4; i1++)
                {
                    if (i1 == i0) continue;
                    for (int i2 = 0; i2 < 4; i2++)
                    {
                        if (i2 == i0 || i2 == i1) continue;
                        for (int i3 = 0; i3 < 4; i3++)
                        {
                            if (i3 == i0 || i3 == i1 || i3 == i2) continue;
                            int hours = arr[i0] * 10 + arr[i1];
                            int minutes = arr[i2] * 10 + arr[i3];
                            bool isDate = hours < 24 && minutes < 60;
                            if (isDate)
                            {
                                if ((hours > maxHours) || (hours == maxHours && minutes > maxMinutes))
                                {
                                    maxHours = hours;
                                    maxMinutes = minutes;
                                }
                            }
                        }
                    }
                }
            }

            if (maxHours < 0 || maxMinutes < 0)
                return "";

            string hoursStr = maxHours.ToString();
            string minutesStr = maxMinutes.ToString();
            if (hoursStr.Length < 2) hoursStr = "0" + hoursStr;
            if (minutesStr.Length < 2) minutesStr = "0" + minutesStr;

            string resStr = $"{hoursStr}:{minutesStr}";
            return resStr;
        }

        #endregion 
        #region Test
        public void Test_949()
        {
            int[] testData1 = { 1, 2, 3, 4 };
            int[] testData2 = { 0, 0, 0, 0 };

            OutputMaster.PrintArray(testData1);
            Console.WriteLine(LargestTimeFromDigits(testData1));

            OutputMaster.PrintArray(testData2);
            Console.WriteLine(LargestTimeFromDigits(testData2));
        }
        #endregion

        #endregion
        #region Task 993

        #region Solution
        public class Solution993
        {
            private int x;
            private int y;
            private int xParent;
            private int yParent;
            private int xDepth;
            private int yDepth;

            public bool Rec(TreeNode root, int depth, int parentRootValue)
            {
                if (root == null) return true;

                if (root.val == x)
                {
                    xDepth = depth;
                    xParent = parentRootValue;
                }
                if (root.val == y)
                {
                    yDepth = depth;
                    yParent = parentRootValue;
                }


                return Rec(root.left, depth + 1, root.val) && Rec(root.right, depth + 1, root.val);
            }
            public bool IsCousins(TreeNode root, int x, int y)
            {
                this.x = x;
                this.y = y;
                this.xDepth = -1;
                this.yDepth = -1;

                Rec(root, 0, -1);
                return xDepth == yDepth && xParent != yParent && xDepth != -1;
            }
        }
        #endregion        
        #region Test
        public void Test_993()
        {
            Solution993 solution = new Solution993();

            int?[] arr1 = { 1, 2, 3, null, 4 };
            TreeNode root1 = GetTreeByArray(arr1);
            int x1 = 2;
            int y1 = 3;
            Console.WriteLine(solution.IsCousins(root1, x1, y1));
        }
        #endregion

        #endregion
        #region Task 1175

        #region Solution
        public class Solution1175
        {
            private bool IsPrime(int n)
            {
                if (n == 2) return true;
                int lim = (int)Math.Sqrt((double)n) + 1;
                while (lim > 1)
                {
                    if (n % lim == 0)
                        return false;
                    lim--;
                }
                return true;
            }
            private int Factorial(int num, int mod = 1000000007)
            {
                int res = 1;
                for (int i = 2; i <= num; i++)
                {
                    res = Multiply(res, i);
                    res %= mod;
                }
                return res;
            }
            private int Multiply(int n1, int n2, int mod = 1000000007)
            {
                return (int)(((long)n1 * (long)n2) % mod);
            }
            public int NumPrimeArrangements(int n)
            {
                int[] PrimeCount = new int[101];
                for (int i = 2; i <= 100; i++)
                    PrimeCount[i] = PrimeCount[i - 1] + (IsPrime(i) ? 1 : 0);
                int p = PrimeCount[n];
                return Multiply(Factorial(PrimeCount[n]), Factorial(n - PrimeCount[n]));
            }
        }
        #endregion        
        #region Test
        public void Test_1175()
        {
            Solution1175 s = new Solution1175();
            P(s.NumPrimeArrangements(100));
        }
        #endregion

        #endregion
        #region Task 1232

        #region Solution
        public class Solution1232
        {
            // y1 = a*x1 + b
            // y2 = a*x2 + b
            // y1-y2 = a*(x1-x2)
            // a = (y1 - y2) / (x1 - x2)
            // b = y1 - a * x1

            // y3, x3 ???
            public bool CheckStraightLine(int[][] coordinates)
            {
                int len = coordinates.Length;
                double x1 = 0, x2 = 0, y1 = 0, y2 = 0;

                // find two points
                bool isFind = false;
                for (int i = 0; i < len - 1; i++)
                {
                    for (int j = i + 1; j < len; j++)
                    {
                        x1 = coordinates[i][0];
                        y1 = coordinates[i][1];
                        x2 = coordinates[j][0];
                        y2 = coordinates[j][1];
                        if (x1 != x2 && y1 != y2)
                        {
                            isFind = true;
                            break;
                        }
                    }
                    if (isFind) break;
                }

                // one coordinate is the same
                if (!isFind)
                {
                    x1 = coordinates[0][0];
                    y1 = coordinates[0][1];
                    x2 = coordinates[1][0];
                    y2 = coordinates[1][1];
                    if (x1 == x2)
                    {
                        int localX = Convert.ToInt32(x1);
                        for (int i = 0; i < len; i++)
                            if (coordinates[i][0] != localX)
                                return false;
                        return true;
                    }
                    if (y1 == y2)
                    {
                        int localY = Convert.ToInt32(y1);
                        for (int i = 0; i < len; i++)
                            if (coordinates[i][1] != localY)
                                return false;
                        return true;
                    }
                }

                // common case
                double a = (y1 - y2) / (x1 - x2);
                double b = y1 - a * x1;

                double x = 0, y = 0;
                foreach (var c in coordinates)
                {
                    x = c[0];
                    y = c[1];
                    if (y != a * x + b)
                        return false;
                }
                return true;
            }
        }
        #endregion        
        #region Test
        public void Test_1232()
        {
            Solution1232 s = new Solution1232();
            int[][] arr1 = {
                new int[] { 1, 1 },
                new int[] { 2, 2 },
                new int[] { 3, 4 },
                new int[] { 4, 5 },
                new int[] { 5, 6 },
                new int[] { 7, 7 }
            };
            int[][] arr2 = {
                new int[] { 1, 2 },
                new int[] { 2, 3 },
                new int[] { 3, 4 },
                new int[] { 4, 5 },
                new int[] { 5, 6 },
                new int[] { 6, 7 }
            };
            int[][] arr3 = {
                new int[] { 0, 0 },
                new int[] { 0, 1 },
                new int[] { 0, -1 }
            };
            P(s.CheckStraightLine(arr1));
            P(s.CheckStraightLine(arr2));
            P(s.CheckStraightLine(arr3));
        }
        #endregion

        #endregion
        #region Task 1275

        #region Solution
        public class Solution1275
        {
            private const int SIZE = 3;
            private int[][] field = new int[SIZE][];
            private GameState State = GameState.Pending;

            public Solution1275() => Reset();

            private void SetGameState()
            {
                int rowCount = field.Length;
                int colomnCount = field[0].Length;
                int spWinner = 0;
                // searching for winner in rows
                for (int i = 0; i < rowCount; i++)
                {
                    spWinner = field[i][0];
                    for (int j = 0; j < colomnCount; j++)
                    {
                        if (spWinner != field[i][j])
                        {
                            spWinner = -1;
                            break;
                        }
                    }
                    if (spWinner == 1) { State = GameState.A; return; }
                    if (spWinner == 2) { State = GameState.B; return; }
                }
                // searching for winner in colomns
                for (int i = 0; i < colomnCount; i++)
                {
                    spWinner = field[0][i];
                    if (spWinner == 0) continue;
                    for (int j = 0; j < rowCount; j++)
                    {
                        if (spWinner != field[j][i])
                        {
                            spWinner = -1;
                            break;
                        }
                    }
                    if (spWinner == 1) { State = GameState.A; return; }
                    if (spWinner == 2) { State = GameState.B; return; }
                }
                // searching for winner in diagonals
                if (field[0][0] != 0)
                {
                    spWinner = field[0][0];
                    for (int i = 0; i < rowCount; i++)
                    {
                        if (spWinner != field[i][i])
                        {
                            spWinner = -1;
                            break;
                        }
                    }
                    if (spWinner == 1) { State = GameState.A; return; }
                    if (spWinner == 2) { State = GameState.B; return; }
                }
                if (field[0][colomnCount - 1] != 0)
                {
                    spWinner = field[0][colomnCount - 1];
                    for (int i = 0; i < colomnCount; i++)
                    {
                        if (spWinner != field[i][colomnCount - 1 - i])
                        {
                            spWinner = -1;
                            break;
                        }
                    }
                    if (spWinner == 1) { State = GameState.A; return; }
                    if (spWinner == 2) { State = GameState.B; return; }
                }

                // check for draw
                bool isDraw = true;
                for (int i = 0; i < rowCount; i++)
                {
                    for (int j = 0; j < rowCount; j++)
                    {
                        if (field[i][j] == 0)
                        {
                            isDraw = false;
                            break;
                        }
                    }
                }
                if (isDraw) State = GameState.Draw;
                else State = GameState.Pending;
            }

            public void SetMoves(int[][] moves)
            {
                int x, y;
                bool isFirstPlayer = true;
                int sign = 1;
                for (int i = 0; i < moves.Length; i++)
                {
                    if (isFirstPlayer) sign = 1;
                    else sign = 2;
                    isFirstPlayer = !isFirstPlayer;

                    x = moves[i][0];
                    y = moves[i][1];
                    field[y][x] = sign;
                }
            }

            public string Tictactoe(int[][] moves)
            {
                SetMoves(moves);
                SetGameState();
                return State switch
                {
                    GameState.A => "A",
                    GameState.B => "B",
                    GameState.Draw => "Draw",
                    GameState.Pending => "Pending",
                    _ => ""
                };
            }
            public void Reset()
            {
                field = new int[SIZE][];
                for (int i = 0; i < SIZE; i++)
                {
                    field[i] = new int[SIZE];
                }
                State = GameState.Pending;
            }
            private enum GameState
            {
                A,
                B,
                Draw,
                Pending
            }
        }

        #endregion
        #region Test
        public void Test_1275()
        {
            Solution1275 s = new Solution1275();
            int[][] arr1 = {
                new int[] {0, 0},
                new int[] {2, 0},
                new int[] {1, 1},
                new int[] {2, 1},
                new int[] {2, 2}
            };
            int[][] arr2 = {
                new int[] {0, 0},
                new int[] {1, 1},
                new int[] {0, 1},
                new int[] {0, 2},
                new int[] {1, 0},
                new int[] {2, 0}
            };
            int[][] arr3 = {
                new int[] {0, 0},
                new int[] {1, 1},
                new int[] {2, 0},
                new int[] {1, 0},
                new int[] {1, 2},
                new int[] {2, 1},
                new int[] {0, 1},
                new int[] {0, 2},
                new int[] {2, 2}
            };

            P(s.Tictactoe(arr1));
            s.Reset();

            P(s.Tictactoe(arr2));
            s.Reset();

            P(s.Tictactoe(arr3));
            s.Reset();
        }
        #endregion

        #endregion
        #region Task 1346

        #region Solution
        public bool CheckIfExist(int[] arr)
        {
            int len = arr.Length;
            List<int> pairArr = new List<int>();
            int nullCounter = 0;
            for (int i = 0; i < len; i++)
            {
                if (arr[i] == 0)
                {
                    nullCounter += 1;
                    if (nullCounter > 1)
                        return true;
                    continue;
                }
                if (arr[i] % 2 == 0)
                    pairArr.Add(arr[i] / 2);
            }
            for (int i = 0; i < len; i++)
            {
                if (pairArr.IndexOf(arr[i]) != -1)
                    return true;
            }
            return false;
        }
        #endregion        
        #region Test
        public void Test_1346()
        {
            int[] test_1 = { -2, 0, 10, -19, 4, 6, -8 };
            Console.WriteLine(CheckIfExist(test_1));
        }
        #endregion

        #endregion
        #region Task 1399

        #region Solution
        public class Solution1399
        {
            public int CountLargestGroup(int n)
            {
                int[] groups = new int[Convert.ToString(n).Length * 9 + 1];
                for (int i = 1; i <= n; i++)
                {
                    groups[FigSum(i)]++;
                }

                int maxGroupVal = 0;
                int maxGroupCount = 0;
                foreach (var g in groups)
                {
                    if (g == maxGroupVal)
                    {
                        maxGroupCount++;
                    }
                    else if (g > maxGroupVal)
                    {
                        maxGroupVal = g;
                        maxGroupCount = 1;
                    }
                }

                return maxGroupCount;
                static int FigSum(int n)
                {
                    int res = 0;
                    while (n > 0)
                    {
                        res += n % 10;
                        n /= 10;
                    }
                    return res;
                }
            }
        }
        #endregion        
        #region Test
        public void Test_1399()
        {
            Solution1399 s = new Solution1399();
            Console.WriteLine(s.CountLargestGroup(9999));
        }
        #endregion

        #endregion
        #region Task 1437

        #region Solution
        public class Solution1437
        {
            public bool KLengthApart(int[] nums, int k)
            {
                int l = 0;
                while (l < nums.Length - 1 && nums[l] == 0) l++;

                int r = nums.Length - 1;
                while (r > 0 && nums[r] == 0) r--;

                int currDist = 0;
                for (int i = l + 1; i <= r; i++)
                {
                    if (nums[i] == 1)
                    {
                        if (currDist < k)
                            return false;
                        currDist = 0;
                    }
                    else
                    {
                        currDist++;
                    }
                }
                return true;
            }
        }
        #endregion        
        #region Test
        public void Test_1437()
        {
            var solution = new Solution1437();
            int[] nums1 = { 0, 0, 0 };
            int k1 = 2;
            Console.WriteLine(solution.KLengthApart(nums1, k1));
        }
        #endregion

        #endregion
        #region Task 1507

        #region Solution
        public string ReformatDate(string date)
        {
            Dictionary<string, string> monthSet = new Dictionary<string, string>()
            {
                {"Jan", "01"},
                {"Feb", "02"},
                {"Mar", "03"},
                {"Apr", "04"},
                {"May", "05"},
                {"Jun", "06"},
                {"Jul", "07"},
                {"Aug", "08"},
                {"Sep", "09"},
                {"Oct", "10"},
                {"Nov", "11"},
                {"Dec", "12"}
            };

            bool isDoubleDay = false;
            string day = "" + date[0];
            if ('0' <= date[1] && date[1] <= '9')
            {
                isDoubleDay = true;
                day += date[1];
            }
            else
            {
                day = "0" + day;
            }

            string month = monthSet[date.Substring(isDoubleDay ? 5 : 4, 3)];
            string year = date.Substring(isDoubleDay ? 9 : 8);

            return $"{year}-{month}-{day}";
        }
        #endregion        
        #region Test
        public void Test_1507()
        {
            Console.WriteLine(ReformatDate("20th Oct 2052"));
        }
        #endregion

        #endregion
        #region Task 1748

        #region Solution
        public class Solution1748
        {
            public int SumOfUnique(int[] nums)
            {
                Array.Sort(nums);
                int currNum = -1;
                int res = 0;
                for (int i = 0; i < nums.Length; i++)
                {
                    if (nums[i] != currNum)
                    {
                        currNum = nums[i];
                        res += currNum;
                    }
                }
                return res;
            }
        }
        #endregion        
        #region Test
        public void Test_1748()
        {
            Solution1748 solution = new Solution1748();
            int[] arr1 = new int[] { 1, 2, 3, 2 };
            Console.WriteLine(solution.SumOfUnique(arr1));
        }
        #endregion

        #endregion
        #region Task 1779

        #region Solution
        public class Solution1779
        {
            public class Point
            {
                public int X { get; set; }
                public int Y { get; set; }
                public int MinDist { get; set; } = Int32.MaxValue;
                public int MinDistInd { get; set; } = -1;

                public Point(int x, int y)
                {
                    this.X = x;
                    this.Y = y;
                }

                public bool HasSameCoordinate(Point p) => this.X == p.X || this.Y == p.Y;
                public int ManhattanDistance(Point p) => Math.Abs(this.X - p.X) + Math.Abs(this.Y - p.Y);

                public void SetManhattanDistance(Point p, int ind)
                {
                    if (!HasSameCoordinate(p)) return;
                    int res = ManhattanDistance(p);
                    if (res < MinDist)
                    {
                        MinDist = res;
                        MinDistInd = ind;
                    }
                }
            }
            public int NearestValidPoint(int x, int y, int[][] points)
            {
                Point initPoint = new Point(x, y);
                Point currPoint = null;
                for (int i = 0; i < points.Length; i++)
                {
                    currPoint = new Point(points[i][0], points[i][1]);
                    initPoint.SetManhattanDistance(currPoint, i);
                }
                return initPoint.MinDistInd;
            }
        }

        #endregion        
        #region Test
        public void Test_1779()
        {
            Solution1779 s = new Solution1779();
            int x1 = 3;
            int y1 = 4;
            int[][] points1 = {
                new int[] { 1, 2 },
                new int[] { 3, 1 },
                new int[] { 2, 4 },
                new int[] { 2, 3 },
                new int[] { 4, 4 }
            };
            P(s.NearestValidPoint(x1, y1, points1));
        }
        #endregion

        #endregion
        #region Task 1844

        #region Solution
        public string ReplaceDigits(string s)
        {
            char Shift(char c, int num)
            {
                return Convert.ToChar(Convert.ToInt32(c) + num);
            }
            for (int i = 1; i < s.Length; i += 2)
            {
                char currChar = Shift(s[i - 1], Convert.ToInt32(s[i]) - 48);
                //.Remove(3, 2).Insert(3, "ZX");
                s = s.Substring(0, i) + currChar + s.Substring(i + 1);
            }
            return s;
        }
        #endregion        
        #region Test
        public void Test_1844()
        {
            Console.WriteLine(ReplaceDigits("a1c1e1"));
        }
        #endregion

        #endregion
        #region Task 2062

        #region Solution
        public int CountVowelSubstrings(string word)
        {
            static bool isVowel(ref Dictionary<char, bool> vowels)
            {
                bool res = true;
                foreach (var p in vowels)
                {
                    res &= p.Value;
                    vowels[p.Key] = false;
                }
                return res;
            }
            static string removeNoVowel(string s, string vowels)
            {
                string res = "";
                foreach (var c in s)
                    if (vowels.IndexOf(c) != -1)
                        res += c;
                return res;
            }

            int res = 0;
            string vowelsStr = "aeiou";
            //word = removeNoVowel(word, vowelsStr);
            int totalLen = word.Length;
            Dictionary<char, bool> vowels = new Dictionary<char, bool>();
            foreach (char c in vowelsStr)
                vowels.Add(c, false);
            for (int currLen = 5; currLen <= totalLen; currLen++)
            {
                for (int startInd = 0; startInd <= (totalLen - currLen); startInd++)
                {
                    string currWord = word.Substring(startInd, currLen);
                    foreach (var c in currWord)
                        if (vowels.ContainsKey(c))
                        {
                            vowels[c] = true;
                        }
                        else
                        {
                            isVowel(ref vowels);
                            break;
                        }

                    if (isVowel(ref vowels))
                        res += 1;
                }
            }
            return res;
        }
        #endregion        
        #region Test
        public void Test_2062()
        {
            Console.WriteLine(CountVowelSubstrings("aeiouu"));
            Console.WriteLine(CountVowelSubstrings("unicornarihan"));
            Console.WriteLine(CountVowelSubstrings("cuaieuouac"));
            Console.WriteLine(CountVowelSubstrings("bbaeixoubb"));
        }
        #endregion

        #endregion
        #region Task 2148

        #region Solution
        public class Solution2148
        {
            public int CountElements(int[] nums)
            {
                int len = nums.Length;
                if (len < 3) return 0;
                Array.Sort(nums);
                int first = nums[0];
                int last = nums[len - 1];
                int res = len - 2;
                for (int i = 1; i < len; i++)
                {
                    if (nums[i] != first)
                        break;
                    res--;
                }
                for (int i = len - 2; i >= 0; i--)
                {
                    if (nums[i] != last)
                        break;
                    res--;
                }
                return res > 0 ? res : 0;
            }
        }
        #endregion
        #region Test
        public void Test_2148()
        {
            Solution2148 s = new Solution2148();
            P(s.CountElements(new int[] { -89, 39, 39, -89, 39, 39 }));
        }
        #endregion

        #endregion
        #region Task 2231

        #region Solution
        public class Solution2231
        {
            public int LargestInteger(int num)
            {
                StringBuilder res = new StringBuilder();
                List<int> odds = new List<int>();
                List<int> evens = new List<int>();

                int d = 0;
                int len = Convert.ToString(num).Length;
                bool isEven = len % 2 == 0;
                while (num > 0)
                {
                    d = num % 10;
                    if (isEven) evens.Add(d);
                    else odds.Add(d);
                    num /= 10;
                    isEven = !isEven;
                }

                odds.Sort();
                odds.Reverse();
                evens.Sort();
                evens.Reverse();

                for (int i = 0; i < len / 2; i++)
                    res.Append($"{odds[i]}{evens[i]}");
                if (len % 2 == 1)
                    res.Append($"{odds[len / 2]}");

                return Convert.ToInt32(res.ToString());
            }
        }
        #endregion        
        #region Test
        public void Test_2231()
        {
            Solution2231 s = new Solution2231();
            P(s.LargestInteger(247));
            //P(s.LargestInteger(1234));
            //P(s.LargestInteger(65875));
        }
        #endregion

        #endregion
        #region Task 2559

        #region Solution
        public int[] VowelStrings(string[] words, int[][] queries)
        {
            List<char> vowels = new List<char> { 'a', 'e', 'i', 'o', 'u' };
            int[] res = new int[queries.Length];
            int[] vowelsCount = new int[words.Length + 1];
            // bool[] isVowels = new bool[words.Length];
            for(int i = 0; i < words.Length; i++)
            {
                int curWordLen = words[i].Length;
                char first = words[i][0];
                char last = words[i][curWordLen - 1];
                bool isVowels = vowels.IndexOf(first) >= 0 && vowels.IndexOf(last) >= 0;
                if (i == 0)
                {
                    if (isVowels)
                    {
                        vowelsCount[i] = 1;
                    }
                    continue;
                }
                if (i == 1 && vowelsCount[0] == 1)
                {
                    vowelsCount[i] = 1;
                    if (isVowels)
                        vowelsCount[i] += 1;
                    continue;
                }
                    
                if (isVowels)
                    vowelsCount[i] = vowelsCount[i - 1] + 1;
                else
                    vowelsCount[i] = vowelsCount[i - 1];
            }


            for (int i = 0; i < queries.Length; i++)
            {
                int l = queries[i][0];
                int r = queries[i][1];
                if (l == 0)
                {
                    res[i] = vowelsCount[r];
                    continue;
                }

                res[i] = vowelsCount[r] - vowelsCount[l-1];
            }
            return res;
        }
        #endregion        
        #region Test
        public void Test_2559()
        {
            //string[] word1 = { "a", "e", "i" };
            //int[][] queries1 = { new int[] { 0, 2 }, new int[] { 0, 1 }, new int[] { 2, 2 } };
            //OutputMaster.PrintArray(VowelStrings(word1, queries1));

            //string[] word2 = { "aba", "bcb", "ece", "aa", "e" };
            //int[][] queries2 = { new int[] { 0, 2 }, new int[] { 1, 4 }, new int[] { 1, 1 } };
            //OutputMaster.PrintArray(VowelStrings(word2, queries2));

            //string[] word3 = { "b", "rmivyakd", "kddwnexxssssnvrske", "vceguisunlxtldqenxiyfupvnsxdubcnaucpoi", "nzwdiataxfkbikbtsjvcbjxtr", "wlelgybcaakrxiutsmwnkuyanvcjczenuyaiy", "eueryyiayq", "bghegfwmwdoayakuzavnaucpur", "ukorsxjfkdojcxgjxgmxbghno", "pmgbiuzcwbsakwkyspeikpzhnyiqtqtfyephqhl", "gsjdpelkbsruooeffnvjwtsidzw", "ugeqzndjtogxjkmhkkczdpqzwcu", "ppngtecadjsirj", "rvfeoxunxaqezkrlr", "adkxoxycpinlmcvmq", "gfjhpxlzmokcmvhjcrbrpfakspscmju", "rgmzhaj", "ychktzwdhfuruhpvdjwfsqjhztshcxdey", "yifrzmmyzvfk", "mircixfzzobcficujgbj", "d", "pxcmwnqknyfkmafzbyajjildngccadudfziknos", "dxmlikjoivggmyasaktllgmfhqpyznc", "yqdbiiqexkemebyuitve" };
            //int[][] queries3 = { new int[] { 5, 21 } };
            //OutputMaster.PrintArray(VowelStrings(word3, queries3));

            string[] word4 = { "a", "e", "i" };
            int[][] queries4 = { new int[] { 0, 2 } };
            OutputMaster.PrintArray(VowelStrings(word4, queries4));
        }
        #endregion

        #endregion
        #region Task 2570

        #region Solution
        public int[][] MergeArrays(int[][] nums1, int[][] nums2)
        {
            Dictionary<int, int> resDict = new Dictionary<int, int>();
            int maxInd = 1000;
            int len1 = nums1.Length;
            int len2 = nums2.Length;
            int i1 = 0;
            int i2 = 0;
            int ind = 1;

            while ((i1 < len1 && i2 < len2) || ind <= maxInd)
            {
                bool isValid1 = true;
                bool isValid2 = true;
                int ind1 = 0;
                int val1 = 0;
                int ind2 = 0;
                int val2 = 0;
                try 
                {
                    ind1 = nums1[i1][0];
                    val1 = nums1[i1][1];
                }
                catch
                {
                    isValid1 = false;
                }
                try
                {
                    ind2 = nums2[i2][0];
                    val2 = nums2[i2][1];
                }
                catch
                {
                    isValid2 = false;
                }


                if (isValid1 && isValid2 && ind == ind1 && ind == ind2)
                {
                    resDict.Add(ind, val1 + val2);
                    i1++;
                    i2++;
                }
                if (isValid1 && ind == ind1 && ind != ind2)
                {
                    resDict.Add(ind, val1);
                    i1++;
                }
                if (isValid2 && ind != ind1 && ind == ind2)
                {
                    resDict.Add(ind, val2);
                    i2++;
                }
                ind++;
            }

            int[][] res = new int[resDict.Count][];
            int resInd = 0;
            foreach (var p in resDict)
            {
                int[] currPair = { p.Key, p.Value };
                res[resInd] = currPair;
                resInd++;
            }
            return res;
        }
        #endregion        
        #region Test
        public void Test_2570()
        {
            int[][] nums1 = { new int[]{ 1, 2 }, new int[] { 2, 3 }, new int[] { 4, 5 } };
            int[][] nums2 = { new int[] { 1, 4 }, new int[] { 3, 2 }, new int[] { 4, 1 } };
            OutputMaster.PrintArray(MergeArrays(nums1, nums2));
        }
        #endregion

        #endregion
        #region Task 2576

        #region Solution
        public int MaxNumOfMarkedIndices(int[] nums)
        {
            Array.Sort(nums);
            int maxNum = nums[nums.Length - 1];
            int dev = 0;
            int maxDev = maxNum / 2;
            List<int> numsList = nums.ToList();
            int res = 0;

            while (numsList.Count > 0 && dev <= maxDev)
            {
                bool isAnyChanged = true;
                while (isAnyChanged) 
                {
                    isAnyChanged = false;
                    for (int i = numsList.Count - 1; i >= 1; i--)
                    {
                        i = (numsList.Count - 1) < i ? (numsList.Count - 1) : i;
                        int currBigNum = numsList[i];
                        int currSmallNum = currBigNum / 2 - dev;

                        if (numsList.IndexOf(currSmallNum) != -1)
                        {
                            res += 2;
                            numsList.Remove(currBigNum);
                            numsList.Remove(currSmallNum);
                            isAnyChanged = true;
                        }
                    }
                }

                dev++;
            }

            return res;
        }
        #endregion        
        #region Test
        public void Test_2576()
        {
            int[] test = { 9, 2, 5, 4 };
            int[] test2 = { 1, 78, 27, 48, 14, 86, 79, 68, 77, 20, 57, 21, 18, 67, 5, 51, 70, 85, 47, 56, 22, 79, 41, 8, 39, 81, 59, 74, 14, 45, 49, 15, 10, 28, 16, 77, 22, 65, 8, 36, 79, 94, 44, 80, 72, 8, 96, 78, 39, 92, 69, 55, 9, 44, 26, 76, 40, 77, 16, 69, 40, 64, 12, 48, 66, 7, 59, 10 };
            Console.WriteLine(MaxNumOfMarkedIndices(test2));
        }
        #endregion

        #endregion
        #region Task 2865

        #region Solution
        public class Solution2865
        {
            public long MaximumSumOfHeights(IList<int> maxHeights)
            {
                long res = 0;
                long currRes, lim, heigh;
                for (int i = 0; i < maxHeights.Count; i++)
                {
                    currRes = maxHeights[i];

                    lim = maxHeights[i];
                    for (int j = i - 1; j >= 0; j--)
                    {
                        heigh = maxHeights[j];
                        if (heigh < lim)
                            lim = heigh;
                        else if (heigh > lim)
                            heigh = lim;
                        currRes += heigh;
                    }

                    lim = maxHeights[i];
                    for (int j = i + 1; j < maxHeights.Count; j++)
                    {
                        heigh = maxHeights[j];
                        if (heigh < lim)
                            lim = heigh;
                        else if (heigh > lim)
                            heigh = lim;
                        currRes += heigh;
                    }

                    res = currRes > res ? currRes : res;
                }
                return res;
            }
        }
        #endregion
        #region Test
        public void Test_2865()
        {
            Solution2865 s = new Solution2865();
            P((double)s.MaximumSumOfHeights(new List<int> { 5, 3, 4, 1, 1 }));
            P((double)s.MaximumSumOfHeights(new List<int> { 6, 5, 3, 9, 2, 7 }));
            P((double)s.MaximumSumOfHeights(new List<int> { 3, 2, 5, 5, 2, 3 }));
        }
        #endregion

        #endregion
        #region Task 2343

        #region Solution
        public class Solution2343
        {
            private const int maxLen = 100;
            private readonly string maxValue;
            public Solution2343()
            {
                StringBuilder s = new StringBuilder();
                for (int i = 0; i < maxLen; i++)
                    s.Append("9");
                maxValue = s.ToString();
            }
            public bool IsGreater(string a, string b)
            {
                // a > b ?
                int len = a.Length;
                if (len != b.Length)
                    return len > b.Length;
                for(int i = 0; i < len; i++)
                {
                    if (a[i] > b[i])
                        return true;
                    else if (a[i] < b[i])
                        return false;
                }
                return false;
            }
            public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries)
            {
                List<int> res = new List<int>();
                int trimInd, ind, lowestNumInd = 0;
                string lowestNum, currNum;
                bool[] mask = new bool[nums.Length];
                foreach (var q in queries) 
                {
                    ind = q[0];
                    trimInd = nums[0].Length - q[1];
                    for (int i = 0; i < mask.Length; i++) mask[i] = true;

                    for (int i = 0; i < ind; i++) 
                    {
                        lowestNum = maxValue;
                        lowestNumInd = -1;
                        for (int j = 0; j < nums.Length; j++)
                        {
                            currNum = nums[j].Substring(trimInd);
                            if (IsGreater(lowestNum, currNum) && mask[j])
                            {
                                lowestNum = currNum;
                                lowestNumInd = j;
                            }
                        }
                        if(lowestNumInd == -1)
                            throw new ArgumentException("AAAAAAA");
                        mask[lowestNumInd] = false;
                    }

                    res.Add(lowestNumInd);
                }
                return res.ToArray();
            }
        }
        #endregion
        #region Test
        public void Test_2343()
        {
            Solution2343 s = new Solution2343();
            string[] nums1 = { "102", "473", "251", "814" };
            int[][] queries1 = 
            {
                new int[] {1, 1},
                new int[] {2, 3},
                new int[] {4, 2},
                new int[] {1, 2}
            };
            OutputMaster.PrintArray(s.SmallestTrimmedNumbers(nums1, queries1));


        }
        #endregion

        #endregion

        #region Task (Number)

        #region Solution

        #endregion
        #region Test
        public void Test_0()
        {

        }
        #endregion

        #endregion
    }
}
